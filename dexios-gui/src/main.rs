use std::io::Read;

use dexios_core::header::{
    HashingAlgorithm, ARGON2ID_LATEST, BLAKE3BALLOON_LATEST, HEADER_VERSION,
};
use dexios_core::primitives::Algorithm;
use dexios_core::protected::Protected;
use domain::storage::Storage;
use domain::utils::gen_passphrase;
use eframe::egui;

#[macro_export]
macro_rules! ui_ok {
    ($res:expr, $message:expr) => {
        match $res {
            Ok(v) => v,
            _ => return message_box($message),
        }
    };
}

fn main() {
    let mut options = eframe::NativeOptions::default();
    options.resizable = false;
    eframe::run_native(
        "DEXIOS",
        options,
        Box::new(|_cc| Box::new(Dexios::default())),
    );
}

#[derive(PartialEq)]
enum Tab {
    Encrypt,
    Decrypt,
    HeaderDetails,
}

struct Dexios {
    encrypt: Encrypt,
    decrypt: Decrypt,
    tab: Tab,
}

#[derive(Clone)]
pub struct Encrypt {
    algorithm: Algorithm,
    hash_algorithm: HashingAlgorithm,
    input_path: String,
    output_path: String,
    key: Key,
    keyfile_path: String,
    password: String,
    password_validation: String,
    autogenerated_passphrase: String,
}

#[derive(Clone)]
pub struct Decrypt {
    input_path: String,
    output_path: String,
    key: Key,
    keyfile_path: String,
    password: String,
}

#[derive(PartialEq, Clone)]
enum Key {
    Keyfile,
    AutoGenerate,
    Password,
}

impl std::fmt::Display for Key {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Key::Keyfile => write!(f, "Keyfile"),
            Key::Password => write!(f, "Password"),
            Key::AutoGenerate => write!(f, "Auto Generate"),
        }
    }
}

#[derive(Debug)]
pub enum Error {
    PasswordsDontMatch,
    EmptyKey,
    Unsupported,
    KeyfileRead,
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use Error::*;
        match self {
            PasswordsDontMatch => f.write_str("The passwords provided don't match"),
            EmptyKey => f.write_str("The provided key is empty"),
            KeyfileRead => f.write_str("Unable to read the keyfile"),
            Unsupported => f.write_str("This feature is not supported with the provided values"),
        }
    }
}

impl std::error::Error for Error {}

impl Key {
    pub fn get_value_for_encrypting(&self, params: &Encrypt) -> Result<Protected<Vec<u8>>, Error> {
        match self {
            Key::Password => {
                if params.password == params.password_validation {
                    Ok(Protected::new(params.password.clone().into_bytes()))
                } else {
                    Err(Error::PasswordsDontMatch)
                }
            }
            Key::AutoGenerate => Ok(Protected::new(
                params.autogenerated_passphrase.clone().into_bytes(),
            )),
            Key::Keyfile => {
                let mut reader = std::fs::File::open(params.keyfile_path.clone())
                    .map_err(|_| Error::KeyfileRead)?;
                let mut secret = Vec::new();
                reader
                    .read_to_end(&mut secret)
                    .map_err(|_| Error::KeyfileRead)?;
                Ok(Protected::new(secret))
            }
        }
    }

    pub fn get_value_for_decrypting(&self, params: &Decrypt) -> Result<Protected<Vec<u8>>, Error> {
        match self {
            Key::Password => Ok(Protected::new(params.password.clone().into_bytes())),
            Key::AutoGenerate => Err(Error::Unsupported),
            Key::Keyfile => {
                let mut reader = std::fs::File::open(params.keyfile_path.clone()).unwrap();
                let mut secret = Vec::new();
                reader.read_to_end(&mut secret).unwrap();
                Ok(Protected::new(secret))
            }
        }
    }
}

impl Default for Encrypt {
    fn default() -> Self {
        Self {
            algorithm: Algorithm::XChaCha20Poly1305,
            hash_algorithm: HashingAlgorithm::Blake3Balloon(BLAKE3BALLOON_LATEST),
            input_path: "".to_owned(),
            output_path: "".to_owned(),
            key: Key::Password,
            keyfile_path: "".to_owned(),
            password: "".to_owned(),
            password_validation: "".to_owned(),
            autogenerated_passphrase: "".to_owned(),
        }
    }
}

impl Default for Decrypt {
    fn default() -> Self {
        Self {
            input_path: "".to_owned(),
            output_path: "".to_owned(),
            key: Key::Password,
            keyfile_path: "".to_owned(),
            password: "".to_owned(),
        }
    }
}

impl Default for Dexios {
    fn default() -> Self {
        Self {
            encrypt: Encrypt::default(),
            decrypt: Decrypt::default(),
            tab: Tab::Encrypt,
        }
    }
}

fn message_box(description: &str) {
    rfd::MessageDialog::new()
        .set_title("Dexios")
        .set_description(description)
        .set_buttons(rfd::MessageButtons::Ok)
        .show();
}

impl eframe::App for Dexios {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        ctx.set_visuals(egui::Visuals::dark());
        egui::CentralPanel::default().show(ctx, |ui| {
            ui.horizontal(|ui| {
                ui.selectable_value(&mut self.tab, Tab::Encrypt, "Encrypt");
                ui.selectable_value(&mut self.tab, Tab::Decrypt, "Decrypt");
                ui.selectable_value(&mut self.tab, Tab::HeaderDetails, "Header Details");
            });

            ui.separator();

            if self.tab == Tab::Encrypt {
                ui.horizontal(|ui| {
                    ui.label("AEAD: ");
                    egui::ComboBox::from_id_source("aead")
                        .selected_text(format!("{}", self.encrypt.algorithm))
                        .show_ui(ui, |ui| {
                            ui.selectable_value(
                                &mut self.encrypt.algorithm,
                                Algorithm::XChaCha20Poly1305,
                                "XChaCha20-Poly1305",
                            );
                            ui.selectable_value(
                                &mut self.encrypt.algorithm,
                                Algorithm::Aes256Gcm,
                                "AES-256-GCM",
                            );
                        });
                });

                ui.horizontal(|ui| {
                    ui.label("Hashing Algorithm: ");
                    egui::ComboBox::from_id_source("hashing")
                        .selected_text(format!("{}", self.encrypt.hash_algorithm))
                        .show_ui(ui, |ui| {
                            ui.selectable_value(
                                &mut self.encrypt.hash_algorithm,
                                HashingAlgorithm::Blake3Balloon(BLAKE3BALLOON_LATEST),
                                "BLAKE3-Balloon",
                            );
                            ui.selectable_value(
                                &mut self.encrypt.hash_algorithm,
                                HashingAlgorithm::Argon2id(ARGON2ID_LATEST),
                                "Argon2id",
                            );
                        });
                });

                ui.horizontal(|ui| {
                    ui.label("Input: ");
                    ui.add(
                        egui::TextEdit::singleline(&mut self.encrypt.input_path)
                            .hint_text("Path to the input file"),
                    );
                    if ui.button("Select File").clicked() {
                        if let Some(path) = rfd::FileDialog::new().pick_file() {
                            self.encrypt.input_path = path.as_path().display().to_string();
                            self.encrypt.output_path = self.encrypt.input_path.clone() + ".dx";
                        }
                    }
                });

                ui.horizontal(|ui| {
                    ui.label("Output File: ");
                    ui.add(
                        egui::TextEdit::singleline(&mut self.encrypt.output_path)
                            .hint_text("Path to the output file"),
                    );
                    if ui.button("Select File").clicked() {
                        if let Some(path) = rfd::FileDialog::new().pick_file() {
                            self.encrypt.output_path = path.as_path().display().to_string();
                        }
                    }
                });

                ui.horizontal(|ui| {
                    ui.radio_value(&mut self.encrypt.key, Key::Password, "Password");
                    ui.radio_value(&mut self.encrypt.key, Key::Keyfile, "Keyfile");
                    if ui
                        .radio_value(&mut self.encrypt.key, Key::AutoGenerate, "Auto Generate")
                        .clicked()
                    {
                        self.encrypt.autogenerated_passphrase =
                            gen_passphrase().expose().to_string();
                    };
                });

                if self.encrypt.key == Key::Password {
                    ui.horizontal(|ui| {
                        ui.label("Password: ");
                        ui.add(
                            egui::TextEdit::singleline(&mut self.encrypt.password)
                                .hint_text("Password: ")
                                .password(true),
                        );
                        ui.add(
                            egui::TextEdit::singleline(&mut self.encrypt.password_validation)
                                .hint_text("Password (for validation): ")
                                .password(true),
                        );
                    });
                }

                if self.encrypt.key == Key::Keyfile {
                    ui.horizontal(|ui| {
                        ui.label("Keyfile: ");

                        ui.add(
                            egui::TextEdit::singleline(&mut self.encrypt.keyfile_path)
                                .hint_text("Path to the keyfile"),
                        );
                        if ui.button("Select File").clicked() {
                            if let Some(path) = rfd::FileDialog::new().pick_file() {
                                self.encrypt.keyfile_path = path.as_path().display().to_string();
                            }
                        }
                    });
                }

                if self.encrypt.key == Key::AutoGenerate {
                    ui.horizontal(|ui| {
                        ui.label("Passphrase: ");
                        ui.add(egui::TextEdit::singleline(
                            &mut self.encrypt.autogenerated_passphrase,
                        ));
                    });
                }

                if ui.button("Encrypt File").clicked() {
                    // encrypty stuff, move to separate function
                    let params = self.encrypt.clone();

                    // discard the error as the user will be alerted to the issue
                    let _ = std::thread::spawn(move || {
                        let stor = std::sync::Arc::new(domain::storage::FileStorage);
                        let input_file = ui_ok!(
                            stor.read_file(params.input_path.clone()),
                            "Unable to read the input file."
                        );
                        let output_file = ui_ok!(
                            stor.create_file(params.output_path.clone())
                                .or_else(|_| stor.write_file(params.output_path.clone())),
                            "Unable to create the output file."
                        );

                        let raw_key = ui_ok!(
                            params.key.get_value_for_encrypting(&params),
                            "Unable to get your key."
                        );

                        let req = domain::encrypt::Request {
                            reader: ui_ok!(
                                input_file.try_reader(),
                                "Unable to get a reader for the input file"
                            ),
                            writer: ui_ok!(
                                output_file.try_writer(),
                                "Unable to get a writer for the output file"
                            ),
                            header_writer: None, // need to add a checkbox and enabled_ui for this
                            raw_key,
                            header_type: dexios_core::header::HeaderType {
                                version: HEADER_VERSION,
                                mode: dexios_core::primitives::Mode::StreamMode,
                                algorithm: params.algorithm,
                            },
                            hashing_algorithm: params.hash_algorithm,
                        };
                        ui_ok!(
                            domain::encrypt::execute(req),
                            "There was an error while encrypting your file"
                        );

                        ui_ok!(
                            stor.flush_file(&output_file),
                            "Unable to flush the output file"
                        );
                    })
                    .join();
                }
            }

            if self.tab == Tab::Decrypt {
                ui.horizontal(|ui| {
                    ui.label("Input File: ");
                    ui.add(
                        egui::TextEdit::singleline(&mut self.decrypt.input_path)
                            .hint_text("Path to the input file"),
                    );
                    if ui.button("Select File").clicked() {
                        if let Some(path) = rfd::FileDialog::new().pick_file() {
                            self.decrypt.input_path = path.as_path().display().to_string();
                            // autoremove .dx extension if it's present, if not, leave blank
                        }
                    }
                });

                ui.horizontal(|ui| {
                    ui.label("Output File: ");
                    ui.add(
                        egui::TextEdit::singleline(&mut self.decrypt.output_path)
                            .hint_text("Path to the output file"),
                    );
                    if ui.button("Select File").clicked() {
                        if let Some(path) = rfd::FileDialog::new().pick_file() {
                            self.decrypt.output_path = path.as_path().display().to_string();
                        }
                    }
                });

                ui.horizontal(|ui| {
                    ui.radio_value(&mut self.decrypt.key, Key::Password, "Password");
                    ui.radio_value(&mut self.decrypt.key, Key::Keyfile, "Keyfile");
                });

                if self.decrypt.key == Key::Password {
                    ui.horizontal(|ui| {
                        ui.label("Password: ");
                        ui.add(
                            egui::TextEdit::singleline(&mut self.decrypt.password)
                                .hint_text("Password: ")
                                .password(true),
                        );
                    });
                }

                if self.decrypt.key == Key::Keyfile {
                    ui.horizontal(|ui| {
                        ui.label("Keyfile: ");

                        ui.add(
                            egui::TextEdit::singleline(&mut self.decrypt.keyfile_path)
                                .hint_text("Path to the keyfile"),
                        );
                        if ui.button("Select File").clicked() {
                            if let Some(path) = rfd::FileDialog::new().pick_file() {
                                self.decrypt.keyfile_path = path.as_path().display().to_string();
                            }
                        }
                    });
                }

                if ui.button("Decrypt File").clicked() {
                    let params = self.decrypt.clone();

                    let _ = std::thread::spawn(move || {
                        // decrypty stuff, move to separate function, add threading+error handling also
                        let stor = std::sync::Arc::new(domain::storage::FileStorage);

                        let input_file = stor.read_file(params.input_path.clone()).unwrap();
                        let output_file = stor
                            .create_file(params.output_path.clone())
                            .or_else(|_| stor.write_file(params.output_path.clone()))
                            .unwrap();

                        let raw_key = params.key.get_value_for_decrypting(&params).unwrap();

                        let req = domain::decrypt::Request {
                            reader: input_file.try_reader().unwrap(),
                            writer: output_file.try_writer().unwrap(),
                            header_reader: None, // need to add a checkbox and enabled_ui for this
                            raw_key,
                            on_decrypted_header: None,
                        };
                        domain::decrypt::execute(req).unwrap();
                    })
                    .join();
                }
            }
        });
    }
}
